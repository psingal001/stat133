### Sample the errors
### Add the errors to the fit to create a y vector
### Return a vector of y values the same length as fit
### HINT: It can be easier to sample the indices than the values
resampled_err <- sample(err, length(fit))
return (fit + resampled_err)
}
fitModel = function(x, y, degree = 1){
### use the lm function to fit a line of a quadratic
### e.g. y ~ x or y ~ x + I(x^2)
### y and x are numeric vectors of the same length
### Return the coefficients as a vector
### HINT: Take a look at the repBoot function to see how to use lm()
if (degree == 1){
coeff <- c(coef(lm(y ~ x)))
} else if (degree == 2){
coeff <- c(coef(lm(y~x + I(x^2))))
}
return(coeff)
}
oneBoot = function(data, fit = NULL, err = NULL degree = 1){
###  data are either your data (from call to getData)
###  OR fit and errors from fit of line to data
###  OR fit and errors from fit of quadratic to data
### Use fitModel to fit a model to this bootstrap Y
if (fit == NULL){
new_y <- genBootY(data$x, data$y)
return(fitModel(data$x, new_y, degree))
} else {
new_y <- genBootR(fit$x, err)
return(fitModel(fit$x, new_y, degree))
}
}
repBoot = function(data, B = 1000){
### Set up the inputs you need for oneBoot, i.e.,
### create errors and fits for line and quadratic
lin_model <- fitModel(data$x, data$y, degree = 1)
lin_fit <- lin_model$fitted
lin_err <- data$y - lin_fit
quad_model <- fitModel(data$x, data$y, degree = 2)
quad_fit <- quad_model$fitted
quad_err <- data$y - quad_fit
### replicate a call to oneBoot B times
### format the return value so that you have a list of
### length 4, one for each set of coefficients
### each element will contain a data frame with B rows
### and one or two columns, depending on whether the
### fit is for a line or a quadratic
### Return this list
lin_Y <- data.frame()
lin_R <- data.frame()
quad_Y <- data.frame()
quad_R <- data.frame()
for (i in 1:B){
coef_lin_Y <- oneBoot(data, degree = 1)
lin_Y <- rbind(lin_Y, coef_lin_Y)
coef_lin_R <- oneBoot(data, lin_fit, lin_err, degree = 1)
lin_R <- rbind(lin_R, coef_lin_R)
coef_quad_Y <- oneBoot(data, degree = 2)
quad_Y <- rbind(quad_Y, coef_quad_Y)
coef_quad_R <- oneBoot(data, quad_fit, quad_err, degree = 2)
quad_R <- rbind(quad_R, coef_quad_R)
}
coeff <- list(lin_Y, lin_R, quad_Y, quad_R)
### Replicate a call to oneBoot B times for
### each of the four conditions
### Format the return value so that you have a list of
### length 4, one for each set of coefficients
### each element will contain a matrix with B columns
### and two or three rows, depending on whether the
### fit is for a line or a quadratic
### Return this list
return(coeff)
}
bootPlot = function(x, y, coeff, trueCoeff){
### x and y are the original data
### coeff is a matrix from repBoot
### trueCoeff contains the true coefficients
### that generated the data
### Make a scatter plot of data
### Add lines or curves for each row in coeff
### Use transparency
### You should use mapply to construct all
### 1000 of the bootstrapped lines of best fit
### Have a look at ?mapply for details.
### This can be done in ggplot2 or base graphics.
### Use trueCoeff to add true line/curve -
###  Make the true line/curve stand out
ggplot(x, y)
myCurve <- function(){
}
#mapply()
}
runSim = function() {
xUnique = 1:5
trueCoeff = c(0, 1, 1)
myData = getData(coefs = trueCoeff, xs = xUnique)
expt = repBoot(data = myData)
par(mfrow = c(2, 2))
for (i in 1:4){
bootPlot(myData$x, myData$y,
coeff = expt[[i]], trueCoeff)
}
return(expt)
}
runSim
runSim()
?plot
plot(x, y, type = "l", col = "red", alpha=0.3))
?alpha
install.packages("scales")
library("scales")
?alphsa
?alpha
?geom_line
library("ggplot")
library("ggplot2")
?geom_line
?curve
?fitted
repBoot = function(data, B = 1000){
### Set up the inputs you need for oneBoot, i.e.,
### create errors and fits for line and quadratic
lin_model <- fitModel(data$x, data$y, degree = 1)
lin_fit <- fitted(lin_model)
lin_err <- data$y - lin_fit
quad_model <- fitModel(data$x, data$y, degree = 2)
quad_fit <- fitted(quad_model)
quad_err <- data$y - quad_fit
### replicate a call to oneBoot B times
### format the return value so that you have a list of
### length 4, one for each set of coefficients
### each element will contain a data frame with B rows
### and one or two columns, depending on whether the
### fit is for a line or a quadratic
### Return this list
lin_Y <- data.frame()
lin_R <- data.frame()
quad_Y <- data.frame()
quad_R <- data.frame()
for (i in 1:B){
coef_lin_Y <- oneBoot(data, degree = 1)
lin_Y <- rbind(lin_Y, coef_lin_Y)
coef_lin_R <- oneBoot(data, lin_fit, lin_err, degree = 1)
lin_R <- rbind(lin_R, coef_lin_R)
coef_quad_Y <- oneBoot(data, degree = 2)
quad_Y <- rbind(quad_Y, coef_quad_Y)
coef_quad_R <- oneBoot(data, quad_fit, quad_err, degree = 2)
quad_R <- rbind(quad_R, coef_quad_R)
}
coeff <- list(lin_Y, lin_R, quad_Y, quad_R)
### Replicate a call to oneBoot B times for
### each of the four conditions
### Format the return value so that you have a list of
### length 4, one for each set of coefficients
### each element will contain a matrix with B columns
### and two or three rows, depending on whether the
### fit is for a line or a quadratic
### Return this list
return(coeff)
}
bootPlot = function(x, y, coeff, trueCoeff){
### x and y are the original data
### coeff is a matrix from repBoot
### trueCoeff contains the true coefficients
### that generated the data
### Make a scatter plot of data
### Add lines or curves for each row in coeff
### Use transparency
### You should use mapply to construct all
### 1000 of the bootstrapped lines of best fit
### Have a look at ?mapply for details.
### This can be done in ggplot2 or base graphics.
### Use trueCoeff to add true line/curve -
###  Make the true line/curve stand out
plot(x, y, type = "l", col = alpha("red", 0.3))
myCurve <- function(a, b, c){
curve(a*x^2 + b*x + c, from = 0, to = 1000)
}
mapply(myCurve, coeff)
}
runSim()
repBoot = function(data, B = 1000){
### Set up the inputs you need for oneBoot, i.e.,
### create errors and fits for line and quadratic
lin_model <- fitModel(data$x, data$y, degree = 1)
lin_fit <- fitted(lin_model)
lin_err <- data$y - lin_fit
quad_model <- fitModel(data$x, data$y, degree = 2)
quad_fit <- fitted(quad_model)
quad_err <- data$y - quad_fit
### replicate a call to oneBoot B times
### format the return value so that you have a list of
### length 4, one for each set of coefficients
### each element will contain a data frame with B rows
### and one or two columns, depending on whether the
### fit is for a line or a quadratic
### Return this list
lin_Y <- data.frame()
lin_R <- data.frame()
quad_Y <- data.frame()
quad_R <- data.frame()
for (i in 1:B){
coef_lin_Y <- oneBoot(data, degree = 1)
lin_Y <- rbind(lin_Y, coef_lin_Y)
coef_lin_R <- oneBoot(data, lin_fit, lin_err, degree = 1)
lin_R <- rbind(lin_R, coef_lin_R)
coef_quad_Y <- oneBoot(data, degree = 2)
quad_Y <- rbind(quad_Y, coef_quad_Y)
coef_quad_R <- oneBoot(data, quad_fit, quad_err, degree = 2)
quad_R <- rbind(quad_R, coef_quad_R)
}
coeff <- list(lin_Y, lin_R, quad_Y, quad_R)
### Replicate a call to oneBoot B times for
### each of the four conditions
### Format the return value so that you have a list of
### length 4, one for each set of coefficients
### each element will contain a matrix with B columns
### and two or three rows, depending on whether the
### fit is for a line or a quadratic
### Return this list
return(coeff)
}
runSim()
?random
?runif
?append
?while
f
?print
x <- 5
while(x < 7){
print(x)
x <- x+1
}
while(x < 9){
print(x)
x <- x+1
}
x <- 5
while(x < 9){
print(x)
x <- x+1
}
runif(3, 1, 6)
runif(3, 1, 6)
?sample
sample.int(1:6, 3)
sample.int(1:6, 3, replace = T)
sample.int(1:6, 3, replace = T)
sample.int(1:6, 3, replace = T)
sample.int(1:6, 3, replace = T)
sample.int(1:6, 3, replace = T)
sample(1:6, 3, replace = T)
sample(1:6, 3, replace = T)
sample(1:6, 3, replace = T)
sample(1:6, 3, replace = T)
sample(1:6, 3, replace = T)
sum(c(1, 4, 5))
x <- sample(1:6, 3, replace = T)
sum(x)
dice_sum <- function(k=2, B=100){
dsum <- c()
for (i in i:B){
die_vals <- sample(1:6, k, replace = T)
print(die_vals)
sum_val <- die_vals
dsum <- append(dsum, sum_val)
}
return (dsum)
}
dice_sum
dice_sum()
dice_sum <- function(k=2, B=100){
dsum <- c()
for (i in 1:B){
die_vals <- sample(1:6, k, replace = T)
print(die_vals)
sum_val <- die_vals
dsum <- append(dsum, sum_val)
}
return (dsum)
}
dice_sum()
dice_sum(B = 5)
dice_sum <- function(k=2, B=100){
dsum <- c()
for (i in 1:B){
die_vals <- sample(1:6, k, replace = T)
print(die_vals)
sum_val <- sum(die_vals)
dsum <- append(dsum, sum_val)
}
return (dsum)
}
dice_sum(B = 5)
dice_sum(k = 7, B = 5)
even <- paste("even", seq(2, 2000, by = 2), sep = "")
even
length(even)
hotelCal <- "On a dark desert highway, cool wind in my hair. Warm smell of colitas, rising up through the air. Up ahead in the distance, I saw a shimmering light. My head grew heavy and my sight grew dim I had to stop for the night.  There she stood in the doorway; I heard the mission bell.  And I was thinking to myself: 'This could be heaven or this could be hell'. Then she lit up a candle and she showed me the way."
hotelCal.split <- unlist(strsplit(hotelCal, " "))
hotelCal.split
?lower
?tolower
hotelCal.split <- tolower(unlist(strsplit(hotelCal, " ")))
hotelCal.split
hotelCal.split <- gsub("[[:punct:]]", "", tolower(unlist(strsplit(hotelCal, " "))))
hotelCal.split
?gsub
library("stringr2")
library("stringr")
?str_extract
?str_sub
str_sub(x, start = 1, end = -2)
x <- "This is just a test"
str_sub(x, start = 1, end = -2)
str_sub(x, start = 1, end = -5)
str_sub(x, start = 1, end = -4)
str_sub(x, start = 6, end = -4)
?substr
substr(x, 5, 1)
substr(x, 4, 1)
substr(x, 7, 1)
substr(x, 7, 4)
substr(x, 7, 9)
substr(x, 7, 7)
substr(x, 0, 1)
text2 <- phrases[substr(phrases, 0, 1) == "d"]
phrases <- c("dog", "doggy", "den", "good boy", "Really?", "How much?", "Only $8", "dogdogdog", "Oh god")
text2 <- phrases[substr(phrases, 0, 1) == "d"]
text2
x <- "hello"
substr(x, length(x)-2, length(x)-2)
substr(x, length(x)-3, length(x)-2)
substr(x, length(x)-3, length(x)-1)
substr(x, length(x), length(x))
substr(x, length(x)-2, length(x))
substr(x, length(x)-2, length(x) - 5)
substr(x, length(x)-2, length(x) - 4)
substr(x, nchar(x)-2, nchar(x))
substr(x, nchar(x)-1, nchar(x))
substr(x, nchar(x)-1, nchar(x)+1)
substr(x, nchar(x)-1, nchar(x)-1)
text1 <- phrases[substr(phrases, nchar(phrases)-1, nchar(phrases)-1) == "o"]
text1
?str_detect
abbreviate <- function(vector, k){
abb_vector <- vector[substr(vector, 1, k)]
return (abb_vector)
}
abbreviate(c("Hello", "number", "awkward"), 3)
x <- c("Hello", "number", "awkward")
x[1]
x[3]
abbreviate(x, 3)
?char
y <- "California"
substr(y, 0, 5)
abbreviate <- function(vector, k){
abb_vector <- vector
for (i in 1:length(vector)){
char <- vector[i]
char <- substr(char, 0, k)
abb_vector[i] <- char
}
return (abb_vector)
}
abbreviate(x, 3)
abbreviate(x, 6)
x <- "May, 2008"
substr(x, nchar(x) - 4, nchar(x))
substr(x, nchar(x) - 3, nchar(x))
?str_replace
updateDate <- function(dates, old.yr) {
date_change <- dates[substr(dates, nchar(dates)-3, nchar(dates)) == old.yr]
updated.dates <- str_replace(date_change, old.yr, "2015")
return(updated.dates)
}
updateDate(c('May, 2008', 'June, 2011'), '2008')
updateDate(c('May, 2008', 'June, 2011', "April, 2008"), '2008')
?str_detect
fruit <- c("apple", "banana", "pear", "pinapple")
str_detect(fruit, [aeiou])
str_detect(fruit, "[aeiou]")
fruit[str_detect(fruit, "[aeiou]")]
fruit[str_detect(fruit, "[eiou]")]
str_detect(phrases, "[[:punct:]]")
phrases[str_detect(phrases, "[[:punct:]]")]
no.punct <- length(phrases[str_detect(phrases, "[[:punct:]]")])
no.punct
text1 <- phrases[substr(phrases, nchar(phrases)-1, nchar(phrases)-1) == "o"]
text1
text2
text2 <- phrases[substr(phrases, 0, 1) == "d"]
text2
no.punct <- length(phrases[str_detect(phrases, "[[:punct:]]")])
no.punct
even <- paste("even", seq(2, 2000, by = 2), sep = "")
length(even)
hotelCal <- "On a dark desert highway, cool wind in my hair. Warm smell of colitas, rising up through the air. Up ahead in the distance, I saw a shimmering light. My head grew heavy and my sight grew dim I had to stop for the night.  There she stood in the doorway; I heard the mission bell.  And I was thinking to myself: 'This could be heaven or this could be hell'. Then she lit up a candle and she showed me the way."
hotelCal.split <- gsub("[[:punct:]]", "", tolower(unlist(strsplit(hotelCal, " "))))
hotelCal.split
install.packages('googleVis')
library('googleVis')
?gvisBubbleChart
head(mtcars)
?rownames
?cbind
mtcars
mtcars <- cbind(mtcars, rownames(mtcars))
mtcars
?gvisBubbleChart
View(mtcars)
?rownames
m2 <- cbind(1, 1:4)
colnames(m2, do.NULL = FALSE)
m2
m2 <- cbind(1, 1:4)
colnames(m2, do.NULL = FALSE)
m2
colnames(m2) <- c("x","Y")
m2
rownames(m2) <- rownames(m2, do.NULL = FALSE, prefix = "Obs.")
m2
mtcars <- colnames(mtcars$rownames(mtcars), c(model))
mtcars <- colnames(mtcars[rownames(mtcars)], c(model))
mtcars <- colnames(mtcars[,rownames(mtcars)], c(model))
mtcars <- colnames(mtcars[,'rownames(mtcars)'], c(model))
colnames
colnames(mtcars[,'rownames(mtcars)']) <- c(model)
colnames(mtcars[,'rownames(mtcars)']) <- c('model')
colnames(mtcars$'rownames(mtcars)') <- c('model')
colnames(mtcars) <- c('model')
mtcars
colnames(mtcars[,-1]) <- c('model')
mtcars
library('googleVis')
head(mtcars)
library('googleVis')
head(mtcars)
mtcars <- cbind(mtcars, rownames(mtcars))
colnames(mtcars[,-1]) <- c('model')
View(mtcars)
mtcars
colnames(mtcars)[colnames(mtcars) == 'rownames(mtcars)'] <- c('model')
head(mtcars)
optionlist <- list(vAxes="[{title:'val1'}, {title:'val2'}]")
bub <- gvisBubbleChart(mtcars, idvar = mtcars$model, xvar = mtcars$disp, yvar = mtcars$mpg,
sizevar = mtcars$hp, colorvar = mtcars$gear, options = optionlist)
bub
bub <- gvisBubbleChart(mtcars, idvar = mtcars$mode, xvar = mtcars$disp, yvar = mtcars$mpg,
sizevar = mtcars$hp, colorvar = mtcars$gear, options = optionlist)
bub
load("WorldBank.RData")
load("WorldBank.RData")
setwd("C:/Users/Pranay/src/stat133/hw9")
load("WorldBank.RData")
View(WorldBank)
WorldDat <- WorldBank[, c("country", "year", "fertility.rate", "life.expectancy",
"population", "region")]
View(WorldDat)
WorldDat <- WorldDat[!is.na(WorldDat)]
WorldDat <- WorldBank[, c("country", "year", "fertility.rate", "life.expectancy",
"population", "region")]
WorldDat <- WorldDat[is.na(WorldDat$population) == F]
WorldDat <- WorldDat[is.na(WorldDat$population) == F,]
View(WorldDat)
WorldDat <- WorldBank[, c("country", "year", "fertility.rate", "life.expectancy",
"population", "region")]
WorldDat <- WorldDat[is.na(WorldDat$fertility.rate) == F,]
View(WorldDat)
WorldDat <- WorldDat[is.na(WorldDat$fertility.rate) == F |
is.na(WorldDat$life.expectancy) == F |
is.na(WorldDat$population) == F,]
View(WorldDat)
WorldDat <- WorldDat[is.na(WorldDat$fertility.rate) == F &
is.na(WorldDat$life.expectancy) == F &
is.na(WorldDat$population) == F,]
View(WorldDat)
WorldDat <- WorldDat[is.na(WorldDat$fertility.rate) == F &
is.na(WorldDat$life.expectancy) == F &
is.na(WorldDat$population) == F &
is.na(WorldDat$region) == F &
is.na(WorldDat$year) == F,]
View(WorldDat)
is.na(WorldDat)
?gvisMotionChart
plot(bub)
optionlist <- list(vAxes="[{title:'val1'}, {title:'val2'}]")
bub <- gvisBubbleChart(mtcars, idvar = mtcars$model, xvar = mtcars$disp, yvar = mtcars$mpg,
sizevar = mtcars$hp, colorvar = mtcars$gear, options = optionlist)
plot(bub)
Motion <- gvisMotionChart(WorldDat, idvar = WorldDat$country, timevar = WorldDat$year,
xvar = WorldDat$life.expectancy,
yvar = WorldDat$fertility.rate, sizevar = WorldDat$population,
colorvar = WorldDat$region)
plot(Motion)
bub <- gvisBubbleChart(mtcars, idvar = "Model", xvar = mtcars$disp, yvar = mtcars$mpg,
sizevar = mtcars$hp, colorvar = mtcars$gear, options = optionlist)
plot(bub)
bub <- gvisBubbleChart(mtcars, idvar = "Model", xvar = mtcars$disp, yvar = mtcars$mpg,
sizevar = mtcars$hp, colorvar = mtcars$gear) #, options = optionlist)
plot(bub)
Motion <- gvisMotionChart(WorldDat, idvar = "Country", timevar = WorldDat$year,
yvar = WorldDat$life.expectancy,
xvar = WorldDat$fertility.rate, sizevar = WorldDat$population,
colorvar = WorldDat$region)
Motion <- gvisMotionChart(WorldDat, idvar = "Country", timevar = "Year",
yvar = WorldDat$life.expectancy,
xvar = WorldDat$fertility.rate, sizevar = WorldDat$population,
colorvar = WorldDat$region)
